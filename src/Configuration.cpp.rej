diff a/src/Configuration.cpp b/src/Configuration.cpp	(rejected hunks)
@@ -327,6 +382,22 @@
         }
     }
 
+    JsonArray xmInverters = doc["xmInverters"];
+    for(uint8_t i = 0; i < XM_INVERTER_MAX; i++) {
+        config.Xm.Inverters[i].Index = i;
+        strlcpy(config.Xm.Inverters[i].DeviceSn,xmInverters[i]["DeviceSn"] | "",sizeof(config.Xm.Inverters[i].DeviceSn));
+        IPAddress ip;
+        ip.fromString(xmInverters[i]["Ip"] | "");
+        config.Xm.Inverters[i].Ip[0] = ip[0];
+        config.Xm.Inverters[i].Ip[1] = ip[1];
+        config.Xm.Inverters[i].Ip[2] = ip[2];
+        config.Xm.Inverters[i].Ip[3] = ip[3];
+        config.Xm.Inverters[i].MaxPower = xmInverters[i]["MaxPower"] | 0;
+        config.Xm.Inverters[i].RatedPower = xmInverters[i]["RatedPower"] | 0;
+        config.Xm.Inverters[i].Type = xmInverters[i]["Type"] | 0;
+        config.Xm.Inverters[i].Open = xmInverters[i]["Open"] | false;
+    }
+
     f.close();
 
     // Check for default DTU serial
@@ -510,4 +581,79 @@
     if (sWriterCount == 0) { sWriterCv.notify_all(); }
 }
 
+XM_INVERTER_T* ConfigurationClass::getXMInverterByDeviceSn(const char* deviceSn) {
+    XM_INVERTER_T* inverters = config.Xm.Inverters;
+    for (int i = 0; i < XM_INVERTER_MAX; ++i) {
+        if (strcmp(inverters[i].DeviceSn, deviceSn) == 0 && inverters[i].Open) {
+            return &inverters[i];
+        }
+    }
+    return nullptr; // Not found
+}
+
+XM_INVERTER_T* ConfigurationClass::getFreeXMInverterSlot() {
+    XM_INVERTER_T* inverters = config.Xm.Inverters;
+    for (int i = 0; i < XM_INVERTER_MAX; ++i) {
+        MessageOutput.println(String("loop index:") + String(i) + String("if check:") + String(inverters[i].DeviceSn[0]  == '\0'));
+        int asciiCode = static_cast<int>(inverters[i].DeviceSn[0]);
+        MessageOutput.println(String("ascii code") +String(asciiCode));
+        if (inverters[i].DeviceSn[0] == '\0' || inverters[i].Open == false) {
+            strlcpy(inverters[i].DeviceSn, "", sizeof(inverters[i].DeviceSn));
+            inverters[i].Open = false;
+            inverters[i].Ip[0] = 0;
+            inverters[i].Ip[1] = 0;
+            inverters[i].Ip[2] = 0;
+            inverters[i].Ip[3] = 0;
+            inverters[i].MaxPower = 0;
+            inverters[i].RatedPower = 0;
+            inverters[i].Type = 0;
+            inverters[i].Index = i;
+            return &inverters[i];
+        }
+    }
+    MessageOutput.println("find No XM inverter Slot");
+    return nullptr; // No free slot
+}
+
+/**
+ * 根据空间中已存在的deviceSn清除DTU中无用
+ */
+void ConfigurationClass::clearInverterSlotBySpaceDeviceSn(String deviceSns){
+    if(deviceSns.length() == 0){
+        MessageOutput.println("未传空间中deviceSn,不做处理.");
+        return;
+    }
+    deviceSns = String(",") + deviceSns + String(",");
+    XM_INVERTER_T* inverters = config.Xm.Inverters;
+    for (int i = 0; i < XM_INVERTER_MAX; ++i) {
+        String deviceSn = String(inverters[i].DeviceSn);
+        String needSearched = String(",") + deviceSn + String(",");
+        MessageOutput.println(String("deviceSns:")+deviceSns);
+        MessageOutput.println(String("needSearched:")+deviceSns);
+        if (inverters[i].DeviceSn[0] == '\0' || inverters[i].Open == false) {
+            continue;
+        }
+
+        if(deviceSns.indexOf(needSearched) < 0){
+            deleteXMInverterByDeviceSn(deviceSn.c_str());
+        }
+    }
+
+}
+
+void ConfigurationClass::deleteXMInverterByDeviceSn(const char* deviceSn) {
+    XM_INVERTER_T* inverter = getXMInverterByDeviceSn(deviceSn);
+    if(inverter != nullptr){
+        strlcpy(inverter->DeviceSn, "", sizeof(inverter->DeviceSn));
+        inverter->Open = false;
+        inverter->Ip[0] = 0;
+        inverter->Ip[1] = 0;
+        inverter->Ip[2] = 0;
+        inverter->Ip[3] = 0;
+        inverter->MaxPower = 0;
+        inverter->RatedPower = 0;
+        inverter->Type = 0;
+    }
+}
+
 ConfigurationClass Configuration;
